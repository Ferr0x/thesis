\documentclass{report}
\usepackage{graphicx}
\usepackage{hyperref}


\begin{document}

% Pagina di Copertina
\begin{titlepage}
    \centering
    \vspace*{\fill}
    \Huge \textbf{THESIS TITLE}
    \vspace{2cm} 
    
    \Large Lorenzo Ferrari

    \vspace{2cm} % Spazio aggiuntivo tra il nome e il nome dell'istituto
    
    \Large Università degli studi di Parma
    \par
    Three-year degree course in Computer Science
    
 
\end{titlepage}

%indice
\renewcommand{\contentsname}{Index}
\tableofcontents
    
    
    
    %overview 
    \chapter{overview}
    introduction and some stuff
    % Capitolo buffer overflow
    \chapter{Buffer Overflow vulnerability}
    \section{background} %---------------------fix this text ------------------
    
    Buffer overflow is a critical vulnerability that emerged around the 1970s and 1980s where it was 
    realized through research which leads the attacker to uncontrolled access to critical points of memory.\newline
    As the 1990s arrived the explosion of the Internet and its client-server infrastructure led large numbers of people to use buffer overflow.\newline
    Furthermore, in this period the first books were published explaining how buffer overflow works.\newline
    In the 2000s people wanted to defend themselves from these types of attacks and invented two types of mitigations:\newline
    \begin{itemize}
        \item[$\bullet$] ASLR (Address Space Layout Randomization)
        \item[$\bullet$] stack canary 
    \end{itemize}
    We will explain this mitigation later.\newline
    Between 2000s and 2010s even with the mitigations attackers managed to avoid them and still exploit buffer overflow vulnerability with technique called:\newline
        \begin{itemize}
        \item[$\bullet$] ROP (Return Oriented Programming)
        \item[$\bullet$] RET2LIBC (Return to Libc)
    \end{itemize}
    Even though vulnerability was born so many years ago it still is one of the biggest an dangerous vulnerablity.
    \clearpage
    %-----------------fix until here--------------------
    \section{How Buffer Overflow works}
    A buffer overflow occurs when the attacker can write more input than expected from the buffer, the overflow input exceeds in the memory in the location right after the buffer we are allocating, this could be very dangerous.\newline
    here's an example:
    \begin{verbatim}
    #include <iostream>
    
    int main() {
    
        char buff[30]; // buffer victim 
        printf(" insert your name: ");
        scanf("%50s",buff); 
        return 0;
    }
    \end{verbatim}
    In this example we can see a bad usage of a scanf function. In fact, this program has a char buffer with a size of 30, but the scanf function can read up to 50 chars.\newline 
    What happens if we insert more input than expected for the buffer?\newline
    State of the buffer before inserting input:
       
    \begin{figure}[h]
    \centering
    \includegraphics[width=13cm]{Organigrammi.png}
    \caption{Empty stack}
    \label{fig:example_empty_buffer}
    \end{figure}
       \clearpage
    In the example, we can notice that we have our buffer instantiated.\newline
    I wrote the question marks instead of 0x0000000000000000 because this memory at the beginning of the program is instantiated for the program we are executing, but this memory had previously been used in other contexts.\newline
    Now we will try to insert the following paylaod:
    \begin{verbatim}
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPPBBBBBBBBCCCCCCCC
    \end{verbatim}
    i used the "A" to fill the buffer "P" for the remaining buffer before RBP, "B" for overwriting the saved base pointer,
    C for overwriting the return address.
    this will cause a buffer overflow because when we get to the assembly instruction leave and ret it will not find the instruction 0x4343434343434343 and the program will receive a segmentation fault.
    \begin{figure}[h]
        \centering
        \includegraphics[width=0.9\linewidth]{example1.png}
        \caption{buffer overflow triggered}
        \label{fig:empty stack}
    \end{figure}
    \newpage
    
    This is how looks the stack after sending this payload:
    \begin{figure}
        \centering
        \includegraphics[width=1\linewidth]{stack_after_overflow.png}
        \caption{Stack after the overflow}
        \label{fig:stack w overflow}
    \end{figure}
    \clearpage
    \section{Mitigations against Buffer Overflow}
    \subsection{Stack Canary}
    The stack canary is a protection that was invented in the 90s to prevent a buffer overflow from occurring.
    It consists of generating a protection value, generated at run time and therefore different for each time a program is executed, but remains for the entire execution of the program.
    The stack canary is placed before important metadata such as the saved base pointer and return address.
    Before executing the epilogue of the function, the integrity of the value of the stack canary is checked. If this has been modified or tampered with, the program will end immediately with the following exit code:
    \begin{verbatim}
    *** stack smashing detected ***: terminated
    \end{verbatim}
    Compilers like gcc by default compile with stack canary, by analyzing the decompiled file the compiler will insert the following lines of code to insert the stack canary.\newline
    \begin{verbatim}
    if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
    \end{verbatim}
    
    The name derives from a small historical note. In fact, the name "stack canary" was inspired by the technique used in coal mines.\newline
    To avoid entering an area of the mine with high levels of toxic gases, they would let a canary fly ahead.\newline
    If the canary died, passage was prohibited; otherwise, they could pass.
    \clearpage
    Following is the photo of the stack extracted from GDB. As we can see, I inserted two commands:
    \begin{itemize}
      \item \hspace{1em} canary: This command shows the possible canaries of this code.
      \item \hspace{1em} stack 20: This command shows 20 stack instances.
    \end{itemize}
    As we can see, at address 0x7fffffffdf68, we have the value 0xe1509a30995e5f00, which is our stack canary.
    \begin{figure}
        \includegraphics[width=1.3\linewidth]{photo_of_the_stack_with_canary.png}
        \caption{ stack canary on gdb }
        \label{fig:  photo stack canary}
    \end{figure}
    \clearpage
    \subsection{ASLR}
    ASLR stands for Address Space Layout Randomization and is a technique they invented to protect operating systems from memory attacks.\newline
    In fact ASLR has the task of randomizing sections of memory such as heap stacks and shared libraries every time a program or operating system is launched.\newline
    ASLR with the stack canary seen previously and PIE that we will see later are mitigations mainly developed to avoid buffer overflow, in fact ASLR for example avoids us from jumping into memory locations that would be in fixed positions if it were not for this mitigation, and it avoids many attacks.\newline
    ASLR can randomize memory segments between a range of:
    \begin{verbatim} 
    2^8(256) to  2^16(65536)
    \end{verbatim}
    on the linux kernel we can check the level of randomization with the following command:
    \begin{verbatim}
    cat /proc/sys/kernel/randomize_va_space
    2
    \end{verbatim}
    the result of the command is 2 this indicate that we have maximum number of randomization in my personal linux kernel.\newline
    Follows a photo that explain how aslr works.
    \begin{figure}[h]
        \centering
        \includegraphics[width=0.8\linewidth]{aslr_explanation.png}
        \caption{ASLR}
        \label{fig:aslr }
    \end{figure}
    \clearpage
    \subsection{PIE}
    PIE stands for Position Independent Executable and is very similar to ASLR, in fact it follows the same concept as ASLR but with the binary assembly memory region.\newline
    As can be interpreted from the name Position Independent gives the possibility for a binary to be loaded and executed in memory at arbitrary addresses, this means that the program data instead of referring to addresses in fixed memory are referenced through the use of an offset random to the current position where it is loaded plus the offset.
    
    \begin{table}[h] % Utilizzo [b] per posizionare la tabella in fondo alla pagina
      \centering
      \begin{tabular}{|c|c|c|c|}
        \hline
        ASLR  & PIE & Binary Address & Libc Address \\
        \hline
        disable & disable  & 0x400000 & 0x7ffff7d86000 \\
        disable & disable  & 0x400000 & 0x7ffff7d86000\\
        disable & activated   & 0×555555554000 & 0x7ffff7d86000 \\
        disable & activated   & 0×555555554000 & 0x7ffff7d86000 \\
        activated  & disable  &  0x400000 & 0x7fe7833eb000 \\
        activated  & disable  &  0x400000& 0x7f1a44191000 \\
        activated  & activated   & 0×555555554000 & 0x7f29d6ebd000 \\
        activated  & activated   & 0×555555554000 & 0x7f7d008a0000 \\
        \hline
      \end{tabular}
    \end{table}
    \clearpage
    \section{How to bypass the mitigation}
    ha senso fare questa slide ?
    \clearpage
    \section{How to exploit a buffer overflow and demonstration of a challenge}
    In this chapter I will explain the techniques used to exploit a buffer overflow and demonstrate how the techniques work with an example of an exploit.\newline
    As a demonstration I used a challenge proposed as training in preparation for the national competition.\newline
    I found and decided to present the following challenge because it includes the bypass of all mitigations and an exploitation technique that is still very effective.\newline
        The challenge is called terminator and two files are attached:

    \begin{itemize}
        \item[$\bullet$] file terminator ELF  
        \item[$\bullet$] libc with which they compiled that binary
    \end{itemize}
    \clearpage
    
    \subsection{Plan and organization of steps to carry out a challenge}
    When it comes to finding bugs in real-world applications or solving cybersecurity challenges, I like to divide the work into four main points: \newline
    \begin{itemize}
        \item[Step 1:] understand the environment
        \item[Step 2:] reverse engineering 
        \item[Step 3:] understand which mitigations are active and think about how to bypass them
        \item[Step 4:] write the exploit and test it
    \end{itemize}

    \subsection{Understand the envirnoment}
    launching the command "file terminator"  we have the first information such as:\newline
    \begin{itemize}
        \item[$\bullet$] terminator is obviously a 64 bit x86-64 elf file.
        \item[$\bullet$] the binary is not stripped, this is positive because it implies that we will have debug symbols and in the reverse engineering phase it helps us a lot .
    \end{itemize}
    \subsection{Reverse Engineering}
    this is one of the most important and complicated phases, in fact from a binary file using tools such as IDA or Ghidra which interpret binary files and decompile them to make this phase easier.\newline
    Certainly, even with very powerful tools like these, the decompiled code will never be as clean as the original code.\newline
    In fact this phase involves an interpretation of the code through the decompiled code and the assembly that is shown.
    I decide to show a challenge with a very simple.
    I decided to show a challenge that has a simple reverse engineering part because the topic of the thesis is the exploitation phase.
    In fact we come across the following function which contains two critical bugs:\newline
    \clearpage
    \begin{figure}[h]
        \includegraphics[width=1.3\linewidth]{terminator_rev.png}
        \caption{victim function on ghidra}
        \label{fig:rev_terminator}
    \end{figure}
    As we can see the decompiled version does not interpret the names of the variables and the types, in this specific case the reverse engineering part is simple but can usually take several hours, after a small adaptation the code we interpreted is the following:\newline
    \begin{figure}
        \centering
        \includegraphics[width=1\linewidth]{terminator_rev2.png}
        \caption{victim function adapted}
        \label{fig:enter-label}
    \end{figure}

    \clearpage
        From this code we can interpret two critical bugs and one mitigation.\newline
    Initially a char buffer of size fifty six is instantiated, some prints are made and then we encounter the first bug.\newline
    The read function, as we can read from the manual, reads the number of bytes indicated within the function, in this specific case fifty six and does not add the null byte by default, in fact the programmer added it manually in the position that reflects the bytes read , however causing an off by one because it will put the null byte in the next byte at the end of the buffer, overwriting the first least significant byte of the next address.\newline
    vulnerable code:\newline
    \begin{verbatim} 
        char buffer [56];
        size = read(0,buffer,56);  
        buffer[(int)size] = '\n';
    \end{verbatim}
    The second critical bug is a buffer overflow where the provenance is requested, in fact it uses the same name buffer to save the provenance.
    Since the buffer is fifty-six characters long and the read has the number of bytes it will read set to seventy-two characters, this undoubtedly causes a buffer overflow of as many as fourteen characters.
    vulnerable code:\newline
    \begin{verbatim} 
    char buffer [56];
    read(0,buffer,72);
    \end{verbatim}
    Finally, from this function we can understand something that we would have analyzed later but realizing it previously already makes us aware of a potential problem.\newline
    In fact, from the decompiled code we find the code used by the compiler to insert the canary stack, which will prevent us from doing buffer overflows without first leaking the canary stack.\newline
    vulnerable code:
    \begin{verbatim} 
    if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                        /* WARNING: Subroutine does not return */
        __stack_chk_fail();
    }
    \end{verbatim}
    
        
    %capitolo heap overflow 
    \chapter{Heap Overflow Vulnerability}
    \section{How it works a Heap Overflow}
    to be continued
    \clearpage
    \section{overview challenge and attack planning}
    to be continued
    \clearpage
    \section{exploit analisys}
    to be continued
    \clearpage
    %capitolo double free
    \chapter{Double Free Vulnerability}
    \section{How it works a Double Free}
    to be continued    
    \clearpage
    \section{overview challenge and attack planning}
    to be continued
    \clearpage
    \section{exploit analisys}
    to be continued
    \clearpage
    % capitolo conclusioni
    \chapter{Conclusion}
    to be continued
    \section{online references}
    \href{https://it.wikipedia.org/wiki/Home_page}{.....}
    \clearpage
\end{document}
